<<<<<<< Updated upstream
kable(variance_table, caption = "Comparison of Proportion of Variance Explained")
# Loadings (correlation matrix eigenvectors)
loadings <- eig$vectors
colnames(loadings) <- paste0("PC", 1:ncol(loadings))
rownames(loadings) <- colnames(df_std)
loadings[, 1:2]  # First two PCs
# Create a loadings matrix: columns are PCs, rows are original variables
loadings <- eig$vectors
# Put into a readable table: just PC1 and PC2
loadings_table <- data.frame(
Variable = colnames(df_std),
PC1 = round(loadings[, 1], 3),
PC2 = round(loadings[, 2], 3)
)
# Display using kable
library(knitr)
kable(loadings_table, caption = "Loadings for the First Two Principal Components")
kable(loadings_table, caption = "Loadings for the First Two Principal Components")
# Calculate the scores for the first principal component
pc1_scores <- df_std %*% eig$vectors[, 1]
# Compute correlation between PC1 scores and each original variable
cor_with_pc1 <- apply(df_std, 2, function(x) cor(x, pc1_scores))
# Combine with the loadings for PC1
comparison_table <- data.frame(
Variable = colnames(df_std),
`Loading (PC1)` = round(eig$vectors[, 1], 3),
`Correlation with PC1` = round(cor_with_pc1, 3)
)
=======
theme_minimal() +
labs(title = "Scatterplot of Family vs Distance to Road after filtering",
x="Distance to Road in km",
y="Family size")
ggplot(df_clean, aes(x = dist_rd, y = cattle)) +
geom_point() +
theme_minimal() +
labs(title = "Scatterplot of Distance to Road vs Cattle after filtering",
x="Distance to Road in km",
y="No. of Cattle")
# Identify and remove outliers
df_clean <- data_tidy_mali[data_tidy_mali$family <= 100 & data_tidy_mali$dist_rd <= 400 & data_tidy_mali$cattle <= 75, ]
ggplot(df_clean, aes(x = dist_rd, y = cattle)) +
geom_point() +
theme_minimal() +
labs(title = "Scatterplot of Distance to Road vs Cattle after filtering",
x="Distance to Road in km",
y="No. of Cattle")
# Identify and remove outliers
df_clean <- data_tidy_mali[data_tidy_mali$family <= 100 & data_tidy_mali$dist_rd <= 200 & data_tidy_mali$cattle <= 75, ]
ggplot(df_clean, aes(x = dist_rd, y = cattle)) +
geom_point() +
theme_minimal() +
labs(title = "Scatterplot of Distance to Road vs Cattle after filtering",
x="Distance to Road in km",
y="No. of Cattle")
pca_table <- data.frame(
PC = paste0("PC", 1:length(eigenvalues)),
Eigenvalue = round(eigenvalues, 3),
`Proportion of Variance` = round(prop_var, 3),
`Cumulative Variance` = round(cum_var, 3)
)
# View eigenvalues and proportion of variance explained
eigenvalues <- eig$values
pca_table <- data.frame(
PC = paste0("PC", 1:length(eigenvalues)),
Eigenvalue = round(eigenvalues, 3),
`Proportion of Variance` = round(prop_var, 3),
`Cumulative Variance` = round(cum_var, 3)
)
cum_var <- cumsum(prop_var)  # cumulative variance explained
pca_table <- data.frame(
PC = paste0("PC", 1:length(eigenvalues)),
Eigenvalue = round(eigenvalues, 3),
`Proportion of Variance` = round(prop_var, 3),
`Cumulative Variance` = round(cum_var, 3)
)
pca_table
ggplot(pca_table, aes(x = PC, y = Eigenvalue)) +
geom_point(size = 3, color = "darkred") +
geom_line(group = 1, color = "darkred") +
theme_minimal() +
labs(title = "Scree Plot",
x = "Principal Components",
y = "Eigenvalue") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
kable(pca_table, caption = "Principal Component Analysis: Variance Explained")
library(knitr)
kable(pca_table, caption = "Principal Component Analysis: Variance Explained")
# SVD on standardized data
svd_res <- svd(df_std)
# SVD on standardized data
svd_res <- svd(df_std)
svd_res
# Perform SVD on the standardized data
svd_res <- svd(df_std)
# Compute scaled squared singular values (equivalent to eigenvalues)
svd_eigenvalues <- svd_res$d^2 / (nrow(df_std) - 1)
# Create a comparison table
comparison_table <- data.frame(
PC = paste0("PC", 1:length(svd_eigenvalues)),
`Eigenvalue (correlation)` = round(eig$values, 3),
`Eigenvalue (SVD)` = round(svd_eigenvalues, 3)
)
library(knitr)
# Display the comparison of eigenvalues
kable(comparison_table, caption = "Comparison of Eigenvalues from Correlation Matrix vs SVD")
# Compute proportion of variance
prop_var_corr <- eig$values / sum(eig$values)
prop_var_svd <- svd_eigenvalues / sum(svd_eigenvalues)
# Create a new table
variance_table <- data.frame(
PC = paste0("PC", 1:length(prop_var_corr)),
`Prop. Variance (correlation)` = round(prop_var_corr, 3),
`Prop. Variance (SVD)` = round(prop_var_svd, 3)
)
# Display the second table
kable(variance_table, caption = "Comparison of Proportion of Variance Explained")
# Loadings (correlation matrix eigenvectors)
loadings <- eig$vectors
colnames(loadings) <- paste0("PC", 1:ncol(loadings))
rownames(loadings) <- colnames(df_std)
loadings[, 1:2]  # First two PCs
# Create a loadings matrix: columns are PCs, rows are original variables
loadings <- eig$vectors
# Put into a readable table: just PC1 and PC2
loadings_table <- data.frame(
Variable = colnames(df_std),
PC1 = round(loadings[, 1], 3),
PC2 = round(loadings[, 2], 3)
)
# Display using kable
library(knitr)
kable(loadings_table, caption = "Loadings for the First Two Principal Components")
kable(loadings_table, caption = "Loadings for the First Two Principal Components")
# Calculate the scores for the first principal component
pc1_scores <- df_std %*% eig$vectors[, 1]
# Compute correlation between PC1 scores and each original variable
cor_with_pc1 <- apply(df_std, 2, function(x) cor(x, pc1_scores))
# Combine with the loadings for PC1
comparison_table <- data.frame(
Variable = colnames(df_std),
`Loading (PC1)` = round(eig$vectors[, 1], 3),
`Correlation with PC1` = round(cor_with_pc1, 3)
)
>>>>>>> Stashed changes
# Display as formatted table using kable
library(knitr)
kable(comparison_table, caption = "Comparison of PC1 Loadings and Correlations with PC1")
kable(comparison_table, caption = "Comparison of PC1 Loadings and Correlations with PC1")
# Combine with the loadings for PC1
comparison_table <- data.frame(
`Loading (PC1)` = round(eig$vectors[, 1], 3),
`Correlation with PC1` = round(cor_with_pc1, 3)
)
kable(comparison_table, caption = "Comparison of PC1 Loadings and Correlations with PC1")
# Create PCA object for plotting
pca_res <- prcomp(df_std, scale. = FALSE)
# Biplot of first two PCs
biplot(pca_res, scale = 0, cex = 0.6)
# Run PCA using prcomp on standardized variables
pca_res <- prcomp(df_std, center = TRUE, scale. = TRUE)
# Biplot of first 2 principal components
library(ggplot2)
library(factoextra)
# Biplot using factoextra
fviz_pca_biplot(
pca_res,
repel = TRUE,
col.var = "steelblue",  # color for variable vectors
col.ind = "gray50",     # color for individuals
title = "Biplot: First Two Principal Components (Standardized Data)"
)
# Run PCA on standardized data
pca_res <- prcomp(df_std, center = TRUE, scale. = TRUE)
# Extract percentage of variance explained for axis labels
pca_var <- pca_res$sdev^2
pca_var_exp <- round(100 * pca_var / sum(pca_var), 1)
# Generate biplot with axis labels showing % variance
library(factoextra)
fviz_pca_biplot(
pca_res,
repel = TRUE,
col.var = "steelblue",
col.ind = "gray50",
title = "Biplot: First Two Principal Components (Standardized Data)"
) +
labs(
x = paste0("PC1 (", pca_var_exp[1], "% variance)"),
y = paste0("PC2 (", pca_var_exp[2], "% variance)")
)
# Run PCA on standardized data
pca_res <- prcomp(df_std, center = TRUE, scale. = TRUE)
pca_var_exp <- round(100 * pca_var / sum(pca_var), 1)
fviz_pca_biplot(
pca_res,
repel = TRUE,
col.var = "steelblue",
col.ind = "gray50",
title = "Biplot: First Two Principal Components (Standardized Data)"
) +
labs(
x = paste0("PC1 (", pca_var_exp[1], "% variance)"),
y = paste0("PC2 (", pca_var_exp[2], "% variance)")
)
##############################33
# Simulate data from the preamble
set.seed(2021)
<<<<<<< Updated upstream
setwd("~/GitHub/research-project")
###### fully time dependent model, no age structure####
library(RMark)
# 1. Load data (from .inp file or dataframe)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# 2. Process multistate data (strata = states)
proc <- process.data(data, model = "Multistrata",
strata.labels = c("1", "2"))  # 1 = nonbreeder, 2 = breeder
# 3. Generate default design data
ddl <- make.design.data(proc)
# 4. Constrain transitions from breeder (state "2") to nonbreeder (state "1") to zero
ddl$Psi$fix <- with(ddl$Psi, ifelse(stratum == "2" & tostratum == "1", 0, NA))
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~stratum * time)
)
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
# 7. View model results
summary(fit.constrained)
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ time)
=======
# fixing input file for marked as young vs adult
library(dplyr)
library(lubridate)
library(readxl)
library(dplyr)
library(tidyr)
library(stringr)
#####------------------------
raw <- read_excel(
"Peregrine ringing data sightings_1989-2024_13042025.xlsx",
sheet = "Re-sightings - annual",
skip = 3 # skip metadata rows
)
setwd("~/GitHub/research-project")
#####------------------------
raw <- read_excel(
"Peregrine ringing data sightings_1989-2024_13042025.xlsx",
sheet = "Re-sightings - annual",
skip = 3 # skip metadata rows
)
# rename the ring ID and the year‐sighted columns, and keep just those plus make an “obs” flag = 1
dat <- raw %>%
rename(
ring      = `ring number`,
date_seen = `date sighted on territory`
) %>%
# turn the POSIX date into an integer year
mutate(year_seen = year(date_seen)) %>%
select(ring, year_seen) %>%
distinct() %>%              # one (ring, year) per bird-year
mutate(obs = 1L)            # 1 = seen
# Build a full table of (ring × all years in your study) and join...so even if a bird wasn't seen in a certain year that (ring, year) pair still exists...to be filled with 0s later
years <- 1997:2019
all_combos <- expand.grid(
ring      = unique(dat$ring),
year_seen = years
)
full <- all_combos %>%
left_join(dat, by = c("ring", "year_seen")) %>%
mutate(obs = replace_na(obs, 0L)) # If a bird was not seen in a year, obs is set to 0 using replace_na.
enc_hist <- full %>%
arrange(ring, year_seen) %>%
pivot_wider(
names_from  = year_seen,
values_from = obs,
names_prefix = "yr",
values_fill  = 0L
)
# drop the ring column if you just want the matrix
ch_matrix <- as.matrix(enc_hist[,-1])
rownames(ch_matrix) <- enc_hist$ring
# Or, if you want a 0/1 string:
cap_hist <- enc_hist %>%
mutate(
caphist_str = apply(select(., starts_with("yr")), 1, paste0, collapse = "")
)
# Optional: add frequency column (if each is unique, all freq = 1)
cap_hist_inp <- cap_hist %>%
select(caphist_str) %>%
mutate(freq = 1)
# Write to .inp file (no header, separated by space)
write.table(
cap_hist_inp,
file = "peregrine_data.inp",
quote = FALSE,
row.names = FALSE,
col.names = FALSE,
sep = " "
)
# Create lines with space-separated columns and semicolon at the end
cap_hist_lines <- apply(cap_hist_inp, 1, function(row) {
paste(paste(row, collapse = " "), ";", sep = "")
})
# Write lines to file
writeLines(cap_hist_lines, "peregrine_data.inp")
#####new year code-----------
#Read the raw data
raw <- read_excel(
"Peregrine ringing data sightings_1989-2024_13042025.xlsx",
sheet = "Re-sightings - annual",
skip  = 3
)
#Compute an "Aug–Jul capture‐year" and flag sightings
dat <- raw %>%
rename(
ring      = `ring number`,
date_seen = `date sighted on territory`
) %>%
mutate(
date_seen = as.Date(date_seen),
cap_year = if_else(
month(date_seen) >= 8, #changed from 9 to 8 because we want aug-july not sept-aug
year(date_seen),
year(date_seen) - 1L
>>>>>>> Stashed changes
)
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
<<<<<<< Updated upstream
# 7. View model results
summary(fit.constrained)
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ stratum *time)
=======
full <- all_combos %>%
left_join(dat, by = c("ring","cap_year")) %>%
mutate(obs = replace_na(obs, 0L))
#Pivot into your 0/1 encounter‐history
enc_hist <- full %>%
arrange(ring, cap_year) %>%
pivot_wider(
names_from   = cap_year,
values_from  = obs,
names_prefix = "yr",
values_fill  = 0L
>>>>>>> Stashed changes
)
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ stratum *time)
)
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
<<<<<<< Updated upstream
# 7. View model results
summary(fit.constrained)
real_estimates = fit.constrained$results$real
real_estimates <- data.frame(Parameter=rownames(real_estimates), real_estimates)
library(writexl)
write_xlsx(real_estimates, "real_estimates.xlsx")
###### fully time dependent model, no age structure####
library(RMark)
# 1. Load data (from .inp file or dataframe)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# 2. Process multistate data (strata = states)
proc <- process.data(data, model = "Multistrata",
strata.labels = c("1", "2"))  # 1 = nonbreeder, 2 = breeder
# 3. Generate default design data
ddl <- make.design.data(proc)
# 4. Constrain transitions from breeder (state "2") to nonbreeder (state "1") to zero
ddl$Psi$fix <- with(ddl$Psi, ifelse(stratum == "2" & tostratum == "1", 0, NA))
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ time)
=======
#checking if any years have all zeros
#count total sightings in each occasion
year_counts <- colSums(ch_matrix)
#see if any occasion has zero sightings
zero_years <- names(year_counts)[year_counts == 0]
year_counts
zero_years
######merging the excel sheets#######
#we've been building histories only from the second sheet, treating resightings like our “captures.” But MARK and other CJS‐type models assume that occasion 1 for each animal is its release (i.e. when it was ringed).
library(readxl)
library(dplyr)
library(tidyr)
library(lubridate)
# file path
path <- "Peregrine ringing data sightings_1989-2024_13042025.xlsx"
#Read & process the “All ringed” sheet (primary captures)
ring_events <- read_excel(path, sheet = "All ringed", skip = 3) %>%
rename(
ring       = `ring number`,
date_event = `date ringed`
) %>%
mutate(
date_event = as.Date(date_event),
# Aug–Jul “capture‐year”
cap_year   = if_else(
month(date_event) >= 8,
year(date_event),
year(date_event) - 1L
),
obs = 1L
) %>%
# keep only seasons 1997–2019
filter(cap_year >= 1997, cap_year <= 2019) %>%
select(ring, cap_year, obs)
#Read & process the “Re-sightings – annual” sheet (recaptures)
sight_events <- read_excel(path, sheet = "Re-sightings - annual", skip = 3) %>%
rename(
ring       = `ring number`,
date_event = `date sighted on territory`
) %>%
mutate(
date_event = as.Date(date_event),
cap_year   = if_else(
month(date_event) >= 8,
year(date_event),
year(date_event) - 1L
),
obs = 1L
) %>%
filter(cap_year >= 1997, cap_year <= 2019) %>%
select(ring, cap_year, obs)
#Combine captures and recaptures, but only for birds ringed ≥1997
dat_all <- bind_rows(
ring_events,
sight_events %>% filter(ring %in% ring_events$ring)
) %>%
distinct()
#Build full bird × season grid and fill zeros
years <- 1997:2019
all_combos <- expand.grid(
ring     = unique(dat_all$ring),
cap_year = years
>>>>>>> Stashed changes
)
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
# 7. View model results
summary(fit.constrained)
# save results
install.packages("writexl")  # Only once
real_estimates = fit.constrained$results$real
real_estimates <- data.frame(Parameter=rownames(real_estimates), real_estimates)
library(writexl)
write_xlsx(real_estimates, "real_estimates.xlsx")
install.packages("writexl")
###### fully time dependent model, no age structure####
library(RMark)
# 1. Load data (from .inp file or dataframe)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# 2. Process multistate data (strata = states)
proc <- process.data(data, model = "Multistrata",
strata.labels = c("1", "2"))  # 1 = nonbreeder, 2 = breeder
# 3. Generate default design data
ddl <- make.design.data(proc)
# 4. Constrain transitions from breeder (state "2") to nonbreeder (state "1") to zero
ddl$Psi$fix <- with(ddl$Psi, ifelse(stratum == "2" & tostratum == "1", 0, NA))
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ time)
)
<<<<<<< Updated upstream
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
# 7. View model results
summary(fit.constrained)
# save results
real_estimates = fit.constrained$results$real
real_estimates <- data.frame(Parameter=rownames(real_estimates), real_estimates)
library(writexl)
write_xlsx(real_estimates, "real_estimates.xlsx")
######Sgt.Pgt.PSIta#############
library(RMark)
# ---- 1. Read your input .inp file
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# ---- 2. Process the data for multistate model
ms.processed <- process.data(data, model = "Multistrata",
strata.labels = c("1","2"))  # 1=NB, 2=B
# ---- 3. Make design data
ddl <- make.design.data(ms.processed)
# ---- 4. Fix impossible transitions (2→1) to 0
ddl$Psi$fix[ddl$Psi$stratum == "2" & ddl$Psi$tostratum == "1"] <- 0
# ---- 5. Collapse ages into 4 bins (or use provided cutpoints)
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"), right = FALSE)
# ---- 6. Model formula list
model.list1 <- list(
S = list(formula = ~ stratum + time),         # Survival: state + time
p = list(formula = ~ stratum + time),         # Recapture: state + time
Psi = list(formula = ~ time + ageclass)       # Transition: time + age
)
# ---- 7. Fit the model
fit1 <- mark(ms.processed, ddl, model.parameters = model.list1)
# ---- 8. View results
summary(fit1)
# save results
install.packages("writexl")  # Only once
real_estimates1 = fit1$results$real
real_estimates1 <- data.frame(Parameter=rownames(real_estimates1), real_estimates1)
# save results
real_estimates1 = fit1$results$real
install.packages("writexl")
# ---- 6. Model formula list
model.list1 <- list(
S = list(formula = ~ stratum + time),         # Survival: state + time
p = list(formula = ~ stratum + time),         # Recapture: state + time
Psi = list(formula = ~ time + ageclass)       # Transition: time + age
)
# ---- 7. Fit the model
fit1 <- mark(ms.processed, ddl, model.parameters = model.list1)
# ---- 8. View results
summary(fit1)
# save results
real_estimates1 = fit1$results$real
real_estimates1 <- data.frame(Parameter=rownames(real_estimates1), real_estimates1)
library(writexl)
write_xlsx(real_estimates1, "real_estimates1.xlsx")
#####baseline model#####
library(RMark)
# Load data
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# Process data
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix impossible transitions
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# Model
model.const <- list(
S   = list(formula = ~stratum),
p   = list(formula = ~stratum),
Psi = list(formula = ~1)
)
fit.const <- mark(ms.processed, ddl, model.parameters = model.const)
# save results
real_estimates2 = fit.const$results$real
real_estimates2 <- data.frame(Parameter=rownames(real_estimates2), real_estimates2)
library(writexl)
write_xlsx(real_estimates2, "real_estimates2.xlsx")
#####simpler additive model-only psi has age effect#####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# Create age classes for NB→B transitions
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model
model.Psiage <- list(
S   = list(formula = ~stratum + time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.Psiage <- mark(ms.processed, ddl, model.parameters = model.Psiage)
# save results
real_estimates3 = fit.Psiage$results$real
real_estimates3 <- data.frame(Parameter=rownames(real_estimates3), real_estimates3)
library(writexl)
write_xlsx(real_estimates3, "real_estimates3.xlsx")
#####survival->age class for nonbreeders####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# NB survival: 2 age classes
ddl$S$ageclass2 <- cut(ddl$S$Age,
breaks = c(0,2,100),
labels = c("young","older"),
right = FALSE)
# NB→B transitions: 5 age classes
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB <- list(
S   = list(formula = ~stratum + I(stratum=="1")*ageclass2 + I(stratum=="2")*time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB <- mark(ms.processed, ddl, model.parameters = model.ageNB)
# ---- 8. View results
summary(fit.ageNB)
# save results
real_estimatesNB = fit.ageNB$results$real
real_estimatesNB <- data.frame(Parameter=rownames(real_estimatesNB), real_estimatesNB)
library(writexl)
write_xlsx(real_estimatesNB, "real_estimatesNB.xlsx")
##### survival varying for nonbreeder and constant for breeders#####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# NB survival: 2 age classes
ddl$S$ageclass2 <- cut(ddl$S$Age,
breaks = c(0,2,100),
labels = c("young","older"),
right = FALSE)
# NB→B transitions: 4 age classes
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB2 <- list(
S   = list(formula = ~stratum + I(stratum=="1")*(ageclass2 + time) + I(stratum=="2")),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB2 <- mark(ms.processed, ddl, model.parameters = model.ageNB2)
# save results
real_estimatesNB2 = fit.ageNB2$results$real
real_estimatesNB2 <- data.frame(Parameter=rownames(real_estimatesNB2), real_estimatesNB2)
library(writexl)
write_xlsx(real_estimatesNB2, "real_estimatesNB2.xlsx")
#####AICs for the above 6 models#####
all.models <- collect.models()
aic.table <- all.models$model.table
write_xlsx(aic.table, "AICc_results.xlsx")
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB <- list(
S   = list(formula = ~ I(stratum=="1")*ageclass2 + I(stratum=="2")*time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB <- mark(ms.processed, ddl, model.parameters = model.ageNB)
# ---- 8. View results
summary(fit.ageNB)
# save results
real_estimatesNB = fit.ageNB$results$real
real_estimatesNB <- data.frame(Parameter=rownames(real_estimatesNB), real_estimatesNB)
library(writexl)
write_xlsx(real_estimatesNB, "real_estimatesNB.xlsx")
##### survival varying for nonbreeder and constant for breeders#####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# NB survival: 2 age classes
ddl$S$ageclass2 <- cut(ddl$S$Age,
breaks = c(0,2,100),
labels = c("young","older"),
right = FALSE)
# NB→B transitions: 4 age classes
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB2 <- list(
S   = list(formula = ~I(stratum=="1")*(ageclass2 + time) + I(stratum=="2")),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB2 <- mark(ms.processed, ddl, model.parameters = model.ageNB2)
# save results
real_estimatesNB2 = fit.ageNB2$results$real
real_estimatesNB2 <- data.frame(Parameter=rownames(real_estimatesNB2), real_estimatesNB2)
library(writexl)
write_xlsx(real_estimatesNB2, "real_estimatesNB2.xlsx")
#####AICs for the above 6 models#####
all.models <- collect.models()
aic.table <- all.models$model.table
write_xlsx(aic.table, "AICc_results.xlsx")
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB2 <- list(
S   = list(formula = ~I(stratum=="1")*(ageclass2 + time) + I(stratum=="2")*time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB2 <- mark(ms.processed, ddl, model.parameters = model.ageNB2)
# save results
real_estimatesNB2 = fit.ageNB2$results$real
real_estimatesNB2 <- data.frame(Parameter=rownames(real_estimatesNB2), real_estimatesNB2)
library(writexl)
write_xlsx(real_estimatesNB2, "real_estimatesNB2.xlsx")
#####AICs for the above 6 models#####
all.models <- collect.models()
aic.table <- all.models$model.table
write_xlsx(aic.table, "AICc_results.xlsx")
# ---- 1. Read your input .inp file
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# ---- 2. Process the data for multistate model
ms.processed <- process.data(data, model = "Multistrata",
strata.labels = c("1","2"))  # 1=NB, 2=B
# ---- 3. Make design data
ddl <- make.design.data(ms.processed)
# ---- 4. Fix impossible transitions (2→1) to 0
ddl$Psi$fix[ddl$Psi$stratum == "2" & ddl$Psi$tostratum == "1"] <- 0
# ---- 5. Collapse ages into 4 bins (or use provided cutpoints)
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"), right = FALSE)
# ---- 6. Model formula list
model.list1 <- list(
S = list(formula = ~ stratum + time),         # Survival: state + time
p = list(formula = ~ stratum + time),         # Recapture: state + time
Psi = list(formula = ~ time + ageclass)       # Transition: time + age
)
# ---- 7. Fit the model
fit1 <- mark(ms.processed, ddl, model.parameters = model.list1)
# ---- 8. View results
summary(fit1)
#####baseline model#####
library(RMark)
# Load data
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# Process data
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix impossible transitions
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# Model
model.const <- list(
S   = list(formula = ~stratum),
p   = list(formula = ~stratum),
Psi = list(formula = ~1)
)
fit.const <- mark(ms.processed, ddl, model.parameters = model.const)
# save results
real_estimates2 = fit.const$results$real
real_estimates2 <- data.frame(Parameter=rownames(real_estimates2), real_estimates2)
library(writexl)
#####survival->age class for nonbreeders####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# NB survival: 2 age classes
ddl$S$ageclass2 <- cut(ddl$S$Age,
breaks = c(0,2,100),
labels = c("young","older"),
right = FALSE)
# NB→B transitions: 5 age classes
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB <- list(
S   = list(formula = ~ I(stratum=="1")*ageclass2 + I(stratum=="2")*time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB <- mark(ms.processed, ddl, model.parameters = model.ageNB)
# ---- 8. View results
summary(fit.ageNB)
# save results
real_estimatesNB = fit.ageNB$results$real
real_estimatesNB <- data.frame(Parameter=rownames(real_estimatesNB), real_estimatesNB)
=======
#Build each line with a trailing semicolon
lines <- with(caphist_inp, paste0(caphist, " ", freq, " ;"))
#Write exactly those lines to your .inp
writeLines(lines, "peregrine_merged_.inp")
#checking if there's any all zero entries
#Find which rows sum to zero
zero_rows <- which(rowSums(ch_matrix) == 0)
#Any all‐zero histories?
any_zero_histories <- length(zero_rows) > 0
any_zero_histories    # TRUE/FALSE
#See which birds they are
if (any_zero_histories) {
rownames(ch_matrix)[zero_rows]
}
#no all zero histories here either so we didn't have to remove any
#####new age class histories#####
library(readxl)
library(dplyr)
library(tidyr)
library(lubridate)
path <- "Peregrine ringing data sightings_1989-2024_13042025.xlsx"
#Process "All ringed"
ring_events <- read_excel(path, sheet = "All ringed", skip = 3) %>%
rename(
ring       = `ring number`,
date_event = `date ringed`,
age        = age              #one-letter codes: n, j, a OR juvenile
) %>%
mutate(
date_event = as.Date(date_event),
cap_year   = if_else(month(date_event) >= 9,
year(date_event),
year(date_event) - 1L),
obs        = 1L
) %>%
#Drop juvenile rows entirely
filter(age %in% c("n","a"),
cap_year >= 1997, cap_year <= 2019) %>%
select(ring, cap_year, obs, age)
#Process "Re-sightings – annual"
sight_events <- read_excel(path, sheet = "Re-sightings - annual", skip = 3) %>%
rename(
ring       = `ring number`,
date_event = `date sighted on territory`
) %>%
mutate(
date_event = as.Date(date_event),
cap_year   = if_else(month(date_event) >= 9,
year(date_event),
year(date_event) - 1L),
obs        = 1L
) %>%
filter(cap_year >= 1997, cap_year <= 2019,
ring %in% ring_events$ring) %>%
select(ring, cap_year, obs)
#Combine captures and recaptures
dat_all <- bind_rows(ring_events, sight_events) %>%
distinct(ring, cap_year, obs)
#Expand to full bird × season
years <- 1997:2019
all_combos <- expand.grid(
ring     = unique(dat_all$ring),
cap_year = years
)
full <- all_combos %>%
left_join(dat_all, by = c("ring","cap_year")) %>%
mutate(obs = replace_na(obs, 0L))
#Pivot to wide & reattach age
enc_hist <- full %>%
arrange(ring, cap_year) %>%
pivot_wider(
names_from   = cap_year,
values_from  = obs,
names_prefix = "yr",
values_fill  = 0L
) %>%
left_join(ring_events %>% distinct(ring, age), by = "ring")
# fixing input file for marked as young vs adult
library(dplyr)
library(tidyr)
inp_age2 <- enc_hist %>%
mutate(
caphist = apply(select(., starts_with("yr")), 1, paste0, collapse = ""),
age_group = case_when(
age == "n" ~ "nestling",
age == "a" ~ "adult"
)
) %>%
count(caphist, age_group) %>%
pivot_wider(names_from = age_group, values_from = n, values_fill = 0) %>%
arrange(caphist)
lines <- with(inp_age2, paste0(caphist, " ", nestling, " ", adult, " ;"))
writeLines(lines, "peregrine_ya.inp")
>>>>>>> Stashed changes
