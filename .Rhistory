kable(variance_table, caption = "Comparison of Proportion of Variance Explained")
# Loadings (correlation matrix eigenvectors)
loadings <- eig$vectors
colnames(loadings) <- paste0("PC", 1:ncol(loadings))
rownames(loadings) <- colnames(df_std)
loadings[, 1:2]  # First two PCs
# Create a loadings matrix: columns are PCs, rows are original variables
loadings <- eig$vectors
# Put into a readable table: just PC1 and PC2
loadings_table <- data.frame(
Variable = colnames(df_std),
PC1 = round(loadings[, 1], 3),
PC2 = round(loadings[, 2], 3)
)
# Display using kable
library(knitr)
kable(loadings_table, caption = "Loadings for the First Two Principal Components")
kable(loadings_table, caption = "Loadings for the First Two Principal Components")
# Calculate the scores for the first principal component
pc1_scores <- df_std %*% eig$vectors[, 1]
# Compute correlation between PC1 scores and each original variable
cor_with_pc1 <- apply(df_std, 2, function(x) cor(x, pc1_scores))
# Combine with the loadings for PC1
comparison_table <- data.frame(
Variable = colnames(df_std),
`Loading (PC1)` = round(eig$vectors[, 1], 3),
`Correlation with PC1` = round(cor_with_pc1, 3)
)
# Display as formatted table using kable
library(knitr)
kable(comparison_table, caption = "Comparison of PC1 Loadings and Correlations with PC1")
kable(comparison_table, caption = "Comparison of PC1 Loadings and Correlations with PC1")
# Combine with the loadings for PC1
comparison_table <- data.frame(
`Loading (PC1)` = round(eig$vectors[, 1], 3),
`Correlation with PC1` = round(cor_with_pc1, 3)
)
kable(comparison_table, caption = "Comparison of PC1 Loadings and Correlations with PC1")
# Create PCA object for plotting
pca_res <- prcomp(df_std, scale. = FALSE)
# Biplot of first two PCs
biplot(pca_res, scale = 0, cex = 0.6)
# Run PCA using prcomp on standardized variables
pca_res <- prcomp(df_std, center = TRUE, scale. = TRUE)
# Biplot of first 2 principal components
library(ggplot2)
library(factoextra)
# Biplot using factoextra
fviz_pca_biplot(
pca_res,
repel = TRUE,
col.var = "steelblue",  # color for variable vectors
col.ind = "gray50",     # color for individuals
title = "Biplot: First Two Principal Components (Standardized Data)"
)
# Run PCA on standardized data
pca_res <- prcomp(df_std, center = TRUE, scale. = TRUE)
# Extract percentage of variance explained for axis labels
pca_var <- pca_res$sdev^2
pca_var_exp <- round(100 * pca_var / sum(pca_var), 1)
# Generate biplot with axis labels showing % variance
library(factoextra)
fviz_pca_biplot(
pca_res,
repel = TRUE,
col.var = "steelblue",
col.ind = "gray50",
title = "Biplot: First Two Principal Components (Standardized Data)"
) +
labs(
x = paste0("PC1 (", pca_var_exp[1], "% variance)"),
y = paste0("PC2 (", pca_var_exp[2], "% variance)")
)
# Run PCA on standardized data
pca_res <- prcomp(df_std, center = TRUE, scale. = TRUE)
pca_var_exp <- round(100 * pca_var / sum(pca_var), 1)
fviz_pca_biplot(
pca_res,
repel = TRUE,
col.var = "steelblue",
col.ind = "gray50",
title = "Biplot: First Two Principal Components (Standardized Data)"
) +
labs(
x = paste0("PC1 (", pca_var_exp[1], "% variance)"),
y = paste0("PC2 (", pca_var_exp[2], "% variance)")
)
##############################33
# Simulate data from the preamble
set.seed(2021)
setwd("~/GitHub/research-project")
###### fully time dependent model, no age structure####
library(RMark)
# 1. Load data (from .inp file or dataframe)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# 2. Process multistate data (strata = states)
proc <- process.data(data, model = "Multistrata",
strata.labels = c("1", "2"))  # 1 = nonbreeder, 2 = breeder
# 3. Generate default design data
ddl <- make.design.data(proc)
# 4. Constrain transitions from breeder (state "2") to nonbreeder (state "1") to zero
ddl$Psi$fix <- with(ddl$Psi, ifelse(stratum == "2" & tostratum == "1", 0, NA))
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~stratum * time)
)
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
# 7. View model results
summary(fit.constrained)
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ time)
)
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
# 7. View model results
summary(fit.constrained)
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ stratum *time)
)
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ stratum *time)
)
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
# 7. View model results
summary(fit.constrained)
real_estimates = fit.constrained$results$real
real_estimates <- data.frame(Parameter=rownames(real_estimates), real_estimates)
library(writexl)
write_xlsx(real_estimates, "real_estimates.xlsx")
###### fully time dependent model, no age structure####
library(RMark)
# 1. Load data (from .inp file or dataframe)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# 2. Process multistate data (strata = states)
proc <- process.data(data, model = "Multistrata",
strata.labels = c("1", "2"))  # 1 = nonbreeder, 2 = breeder
# 3. Generate default design data
ddl <- make.design.data(proc)
# 4. Constrain transitions from breeder (state "2") to nonbreeder (state "1") to zero
ddl$Psi$fix <- with(ddl$Psi, ifelse(stratum == "2" & tostratum == "1", 0, NA))
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ time)
)
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
# 7. View model results
summary(fit.constrained)
# save results
install.packages("writexl")  # Only once
real_estimates = fit.constrained$results$real
real_estimates <- data.frame(Parameter=rownames(real_estimates), real_estimates)
library(writexl)
write_xlsx(real_estimates, "real_estimates.xlsx")
install.packages("writexl")
###### fully time dependent model, no age structure####
library(RMark)
# 1. Load data (from .inp file or dataframe)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# 2. Process multistate data (strata = states)
proc <- process.data(data, model = "Multistrata",
strata.labels = c("1", "2"))  # 1 = nonbreeder, 2 = breeder
# 3. Generate default design data
ddl <- make.design.data(proc)
# 4. Constrain transitions from breeder (state "2") to nonbreeder (state "1") to zero
ddl$Psi$fix <- with(ddl$Psi, ifelse(stratum == "2" & tostratum == "1", 0, NA))
# 5. Define the model with time-dependent parameters
model.list <- list(
S = list(formula = ~stratum * time),
p = list(formula = ~stratum * time),
Psi = list(formula = ~ time)
)
# 6. Fit the model
fit.constrained <- mark(
data = proc,
ddl = ddl,
model.parameters = model.list,
output = FALSE
)
# 7. View model results
summary(fit.constrained)
# save results
real_estimates = fit.constrained$results$real
real_estimates <- data.frame(Parameter=rownames(real_estimates), real_estimates)
library(writexl)
write_xlsx(real_estimates, "real_estimates.xlsx")
######Sgt.Pgt.PSIta#############
library(RMark)
# ---- 1. Read your input .inp file
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# ---- 2. Process the data for multistate model
ms.processed <- process.data(data, model = "Multistrata",
strata.labels = c("1","2"))  # 1=NB, 2=B
# ---- 3. Make design data
ddl <- make.design.data(ms.processed)
# ---- 4. Fix impossible transitions (2→1) to 0
ddl$Psi$fix[ddl$Psi$stratum == "2" & ddl$Psi$tostratum == "1"] <- 0
# ---- 5. Collapse ages into 4 bins (or use provided cutpoints)
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"), right = FALSE)
# ---- 6. Model formula list
model.list1 <- list(
S = list(formula = ~ stratum + time),         # Survival: state + time
p = list(formula = ~ stratum + time),         # Recapture: state + time
Psi = list(formula = ~ time + ageclass)       # Transition: time + age
)
# ---- 7. Fit the model
fit1 <- mark(ms.processed, ddl, model.parameters = model.list1)
# ---- 8. View results
summary(fit1)
# save results
install.packages("writexl")  # Only once
real_estimates1 = fit1$results$real
real_estimates1 <- data.frame(Parameter=rownames(real_estimates1), real_estimates1)
# save results
real_estimates1 = fit1$results$real
install.packages("writexl")
# ---- 6. Model formula list
model.list1 <- list(
S = list(formula = ~ stratum + time),         # Survival: state + time
p = list(formula = ~ stratum + time),         # Recapture: state + time
Psi = list(formula = ~ time + ageclass)       # Transition: time + age
)
# ---- 7. Fit the model
fit1 <- mark(ms.processed, ddl, model.parameters = model.list1)
# ---- 8. View results
summary(fit1)
# save results
real_estimates1 = fit1$results$real
real_estimates1 <- data.frame(Parameter=rownames(real_estimates1), real_estimates1)
library(writexl)
write_xlsx(real_estimates1, "real_estimates1.xlsx")
#####baseline model#####
library(RMark)
# Load data
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# Process data
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix impossible transitions
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# Model
model.const <- list(
S   = list(formula = ~stratum),
p   = list(formula = ~stratum),
Psi = list(formula = ~1)
)
fit.const <- mark(ms.processed, ddl, model.parameters = model.const)
# save results
real_estimates2 = fit.const$results$real
real_estimates2 <- data.frame(Parameter=rownames(real_estimates2), real_estimates2)
library(writexl)
write_xlsx(real_estimates2, "real_estimates2.xlsx")
#####simpler additive model-only psi has age effect#####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# Create age classes for NB→B transitions
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model
model.Psiage <- list(
S   = list(formula = ~stratum + time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.Psiage <- mark(ms.processed, ddl, model.parameters = model.Psiage)
# save results
real_estimates3 = fit.Psiage$results$real
real_estimates3 <- data.frame(Parameter=rownames(real_estimates3), real_estimates3)
library(writexl)
write_xlsx(real_estimates3, "real_estimates3.xlsx")
#####survival->age class for nonbreeders####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# NB survival: 2 age classes
ddl$S$ageclass2 <- cut(ddl$S$Age,
breaks = c(0,2,100),
labels = c("young","older"),
right = FALSE)
# NB→B transitions: 5 age classes
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB <- list(
S   = list(formula = ~stratum + I(stratum=="1")*ageclass2 + I(stratum=="2")*time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB <- mark(ms.processed, ddl, model.parameters = model.ageNB)
# ---- 8. View results
summary(fit.ageNB)
# save results
real_estimatesNB = fit.ageNB$results$real
real_estimatesNB <- data.frame(Parameter=rownames(real_estimatesNB), real_estimatesNB)
library(writexl)
write_xlsx(real_estimatesNB, "real_estimatesNB.xlsx")
##### survival varying for nonbreeder and constant for breeders#####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# NB survival: 2 age classes
ddl$S$ageclass2 <- cut(ddl$S$Age,
breaks = c(0,2,100),
labels = c("young","older"),
right = FALSE)
# NB→B transitions: 4 age classes
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB2 <- list(
S   = list(formula = ~stratum + I(stratum=="1")*(ageclass2 + time) + I(stratum=="2")),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB2 <- mark(ms.processed, ddl, model.parameters = model.ageNB2)
# save results
real_estimatesNB2 = fit.ageNB2$results$real
real_estimatesNB2 <- data.frame(Parameter=rownames(real_estimatesNB2), real_estimatesNB2)
library(writexl)
write_xlsx(real_estimatesNB2, "real_estimatesNB2.xlsx")
#####AICs for the above 6 models#####
all.models <- collect.models()
aic.table <- all.models$model.table
write_xlsx(aic.table, "AICc_results.xlsx")
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB <- list(
S   = list(formula = ~ I(stratum=="1")*ageclass2 + I(stratum=="2")*time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB <- mark(ms.processed, ddl, model.parameters = model.ageNB)
# ---- 8. View results
summary(fit.ageNB)
# save results
real_estimatesNB = fit.ageNB$results$real
real_estimatesNB <- data.frame(Parameter=rownames(real_estimatesNB), real_estimatesNB)
library(writexl)
write_xlsx(real_estimatesNB, "real_estimatesNB.xlsx")
##### survival varying for nonbreeder and constant for breeders#####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# NB survival: 2 age classes
ddl$S$ageclass2 <- cut(ddl$S$Age,
breaks = c(0,2,100),
labels = c("young","older"),
right = FALSE)
# NB→B transitions: 4 age classes
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB2 <- list(
S   = list(formula = ~I(stratum=="1")*(ageclass2 + time) + I(stratum=="2")),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB2 <- mark(ms.processed, ddl, model.parameters = model.ageNB2)
# save results
real_estimatesNB2 = fit.ageNB2$results$real
real_estimatesNB2 <- data.frame(Parameter=rownames(real_estimatesNB2), real_estimatesNB2)
library(writexl)
write_xlsx(real_estimatesNB2, "real_estimatesNB2.xlsx")
#####AICs for the above 6 models#####
all.models <- collect.models()
aic.table <- all.models$model.table
write_xlsx(aic.table, "AICc_results.xlsx")
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB2 <- list(
S   = list(formula = ~I(stratum=="1")*(ageclass2 + time) + I(stratum=="2")*time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB2 <- mark(ms.processed, ddl, model.parameters = model.ageNB2)
# save results
real_estimatesNB2 = fit.ageNB2$results$real
real_estimatesNB2 <- data.frame(Parameter=rownames(real_estimatesNB2), real_estimatesNB2)
library(writexl)
write_xlsx(real_estimatesNB2, "real_estimatesNB2.xlsx")
#####AICs for the above 6 models#####
all.models <- collect.models()
aic.table <- all.models$model.table
write_xlsx(aic.table, "AICc_results.xlsx")
# ---- 1. Read your input .inp file
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# ---- 2. Process the data for multistate model
ms.processed <- process.data(data, model = "Multistrata",
strata.labels = c("1","2"))  # 1=NB, 2=B
# ---- 3. Make design data
ddl <- make.design.data(ms.processed)
# ---- 4. Fix impossible transitions (2→1) to 0
ddl$Psi$fix[ddl$Psi$stratum == "2" & ddl$Psi$tostratum == "1"] <- 0
# ---- 5. Collapse ages into 4 bins (or use provided cutpoints)
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"), right = FALSE)
# ---- 6. Model formula list
model.list1 <- list(
S = list(formula = ~ stratum + time),         # Survival: state + time
p = list(formula = ~ stratum + time),         # Recapture: state + time
Psi = list(formula = ~ time + ageclass)       # Transition: time + age
)
# ---- 7. Fit the model
fit1 <- mark(ms.processed, ddl, model.parameters = model.list1)
# ---- 8. View results
summary(fit1)
#####baseline model#####
library(RMark)
# Load data
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
# Process data
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix impossible transitions
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# Model
model.const <- list(
S   = list(formula = ~stratum),
p   = list(formula = ~stratum),
Psi = list(formula = ~1)
)
fit.const <- mark(ms.processed, ddl, model.parameters = model.const)
# save results
real_estimates2 = fit.const$results$real
real_estimates2 <- data.frame(Parameter=rownames(real_estimates2), real_estimates2)
library(writexl)
#####survival->age class for nonbreeders####
library(RMark)
data <- convert.inp("peregrine_multistate_final.inp", group.df = NULL)
ms.processed <- process.data(data, model = "Multistrata", strata.labels = c("1","2"))
ddl <- make.design.data(ms.processed)
# Fix breeder → nonbreeder to 0
ddl$Psi$fix[ddl$Psi$stratum=="2" & ddl$Psi$tostratum=="1"] <- 0
# NB survival: 2 age classes
ddl$S$ageclass2 <- cut(ddl$S$Age,
breaks = c(0,2,100),
labels = c("young","older"),
right = FALSE)
# NB→B transitions: 5 age classes
ddl$Psi$ageclass <- cut(ddl$Psi$Age,
breaks = c(0,2,3,4,100),
labels = c("1","2","3","4"),
right = FALSE)
# Model: NB survival depends on ageclass2, B survival varies by time
model.ageNB <- list(
S   = list(formula = ~ I(stratum=="1")*ageclass2 + I(stratum=="2")*time),
p   = list(formula = ~stratum + time),
Psi = list(formula = ~ageclass)
)
fit.ageNB <- mark(ms.processed, ddl, model.parameters = model.ageNB)
# ---- 8. View results
summary(fit.ageNB)
# save results
real_estimatesNB = fit.ageNB$results$real
real_estimatesNB <- data.frame(Parameter=rownames(real_estimatesNB), real_estimatesNB)
